name: docker-ci

on:
  pull_request:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
      - '.github/workflows/**'
  push:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
      - '.github/workflows/**'

permissions:
  contents: read

concurrency:
  group: docker-ci-${{ github.ref }}
  cancel-in-progress: true

env:
  IMAGE_NAME: altheasignals/boxofports

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set meta (CI version + local tag)
        id: meta
        run: |
          # CI-only version string; real releases come from tags.
          V="0.0.0-ci-${GITHUB_SHA::12}"
          echo "version=$V" >> $GITHUB_OUTPUT
          echo "local_tag=${{ env.IMAGE_NAME }}:ci-${GITHUB_SHA::12}" >> $GITHUB_OUTPUT
          echo "Using CI version: $V"
          echo "Local tag: ${{ env.IMAGE_NAME }}:ci-${GITHUB_SHA::12}"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      # Validate both architectures compile (no push, cache-only)
      - name: Build (multi-arch validate, no push)
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: false
          outputs: type=cacheonly
          build-args: |
            VERSION=${{ steps.meta.outputs.version }}
          labels: |
            org.opencontainers.image.version=${{ steps.meta.outputs.version }}
            io.boxofports.version=${{ steps.meta.outputs.version }}
            io.boxofports.track=dev
            io.boxofports.stable=false
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Load amd64 image locally to run a quick smoke test
      - name: Build (amd64, load locally for tests)
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64
          load: true
          tags: ${{ steps.meta.outputs.local_tag }}
          build-args: |
            VERSION=${{ steps.meta.outputs.version }}
          labels: |
            org.opencontainers.image.version=${{ steps.meta.outputs.version }}
            io.boxofports.version=${{ steps.meta.outputs.version }}
            io.boxofports.track=dev
            io.boxofports.stable=false
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Smoke test (--version)
        run: |
          set -euo pipefail
          # Try a quick, non-interactive invocation. Adjust if your entrypoint differs.
          timeout 20s docker run --rm ${{ steps.meta.outputs.local_tag }} --version || {
            echo "::warning::'--version' failed; trying '--help' as a fallback."
            timeout 20s docker run --rm ${{ steps.meta.outputs.local_tag }} --help
          }

      - name: Install jq (for label parsing)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Read image labels (expected to match CI version)
        id: labels
        run: |
          lbl_json=$(docker inspect ${{ steps.meta.outputs.local_tag }} --format '{{json .Config.Labels}}')
          echo "labels_raw=$lbl_json" >> $GITHUB_OUTPUT
          label_version=$(echo "$lbl_json" | jq -r '.["org.opencontainers.image.version"] // .["io.boxofports.version"] // empty')
          echo "version=$label_version" >> $GITHUB_OUTPUT
          echo "Image label version: ${label_version:-<none>}"

      - name: Resolve Python package version inside the container
        id: pkgver
        run: |
          # Ask Python inside the image what version of 'boxofports' is installed
          pkg_version=$(docker run --rm ${{ steps.meta.outputs.local_tag }} \
            python -c "import importlib.metadata as m; print(m.version('boxofports'))" 2>/dev/null || true)
          echo "version=$pkg_version" >> $GITHUB_OUTPUT
          echo "Package version (importlib.metadata): ${pkg_version:-<none>}"

      - name: Compare versions and print summary
        run: |
          set -euo pipefail
          exp="${{ steps.meta.outputs.version }}"
          lbl="${{ steps.labels.outputs.version }}"
          pkg="${{ steps.pkgver.outputs.version }}"

          {
            echo "### Version Alignment Check"
            echo ""
            echo "- **Expected (CI meta)**: \`$exp\`"
            echo "- **Image label**: \`${lbl:-<none>}\`"
            echo "- **Python package (inside image)**: \`${pkg:-<none>}\`"
          } >> $GITHUB_STEP_SUMMARY

          fail=0
          [ "$lbl" = "$exp" ] || { echo "::error::Image label '$lbl' != expected '$exp'"; fail=1; }
          [ "$pkg" = "$exp" ] || { echo "::error::Package version '$pkg' != expected '$exp'"; fail=1; }
          if [ $fail -ne 0 ]; then
            echo "::error::Version mismatch detected."
            exit 1
          fi

      - name: Emit CI summary
        run: |
          {
            echo ""
            echo "âœ… Docker CI build OK"
            echo "- Built multi-arch (validate only), loaded amd64, smoke-tested."
            echo "- Versions aligned across CI meta, image labels, and runtime package."
            echo ""
            echo "_Note: No images were pushed. Publishing is handled by **publish-on-tag.yml** after tag creation._"
          } >> $GITHUB_STEP_SUMMARY
