name: promote-any-to-stable

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Promotion mode"
        type: choice
        required: true
        default: by_version
        options: [by_version, by_digest, rollback_previous_stable]
      target_version:
        description: "X.Y.Z when mode=by_version"
        required: false
      target_digest:
        description: "sha256:â€¦ when mode=by_digest"
        required: false
      update_release:
        description: "Flip GitHub Release to non-prerelease if a version is known"
        type: choice
        required: false
        default: "true"
        options: ["true", "false"]
      dry_run:
        description: "Preview only (no retag)"
        type: choice
        required: false
        default: "false"
        options: ["false", "true"]
      confirm:
        description: 'Type YES to confirm emergency promotion'
        required: true

permissions:
  contents: write

concurrency:
  group: promote-any-to-stable
  cancel-in-progress: false

env:
  IMAGE: docker.io/altheasignals/boxofports

jobs:
  promote:
    runs-on: ubuntu-latest
    steps:
      - name: Validate confirmation
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "YES" ]; then
            echo "::error::Confirmation failed. Type YES to proceed."
            exit 1
          fi

      - name: Checkout (needed for rollback mode to read tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install tools (jq + skopeo)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq skopeo

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker login
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Capture current :stable state
        id: current_stable
        env:
          DH_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          DH_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          AUTH=""
          if [ -n "$DH_USER" ] && [ -n "$DH_TOKEN" ]; then
            AUTH="--creds ${DH_USER}:${DH_TOKEN}"
          fi

          # Resolve current stable digest
          stable_out=$(docker buildx imagetools inspect "${{ env.IMAGE }}:stable" 2>/dev/null || true)
          stable_digest=$(echo "$stable_out" | sed -n 's/^Name:\s\+\(.*@sha256:[0-9a-f]\+\).*$/\1/p' | head -n1 | awk -F@ '{print $2}')
          echo "digest=${stable_digest}" >> $GITHUB_OUTPUT

          # Resolve stable version label if present
          ver=""
          if skopeo inspect $AUTH docker://${{ env.IMAGE }}:stable > /tmp/ins.json 2>/dev/null; then
            ver=$(jq -r '.Labels["org.opencontainers.image.version"] // .Labels["io.boxofports.version"] // empty' /tmp/ins.json)
          fi
          echo "version=$ver" >> $GITHUB_OUTPUT

          echo "Current stable digest: ${stable_digest:-<unknown>}"
          echo "Current stable version label: ${ver:-<unknown>}"

      - name: Validate inputs per mode
        run: |
          mode="${{ github.event.inputs.mode }}"
          case "$mode" in
            by_version)
              tv="${{ github.event.inputs.target_version }}"
              if ! echo "$tv" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
                echo "::error::mode=by_version requires target_version X.Y.Z"
                exit 1
              fi
              ;;
            by_digest)
              td="${{ github.event.inputs.target_digest }}"
              if ! echo "$td" | grep -Eq '^sha256:[0-9a-f]{64}$'; then
                echo "::error::mode=by_digest requires target_digest sha256:<64-hex>"
                exit 1
              fi
              ;;
            rollback_previous_stable)
              # no extra input required
              ;;
            *)
              echo "::error::Invalid mode '$mode'"
              exit 1
              ;;
          esac

      - name: Resolve target digest and version (by_version)
        id: byver
        if: ${{ github.event.inputs.mode == 'by_version' }}
        run: |
          V="${{ github.event.inputs.target_version }}"
          out=$(docker buildx imagetools inspect "${{ env.IMAGE }}:${V}" 2>/dev/null || true)
          digest=$(echo "$out" | sed -n 's/^Name:\s\+\(.*@sha256:[0-9a-f]\+\).*$/\1/p' | head -n1 | awk -F@ '{print $2}')
          if [ -z "$digest" ]; then
            echo "::error::Could not resolve digest for :$V. Ensure publish-on-tag ran successfully."
            exit 1
          fi
          echo "digest=$digest" >> $GITHUB_OUTPUT
          echo "version=$V" >> $GITHUB_OUTPUT
          echo "Resolved :$V digest: $digest"

      - name: Resolve target digest (by_digest)
        id: bydig
        if: ${{ github.event.inputs.mode == 'by_digest' }}
        run: |
          D="${{ github.event.inputs.target_digest }}"
          # Basic sanity check by trying to create a temp tag and immediately delete it in dry mode
          echo "digest=$D" >> $GITHUB_OUTPUT
          echo "version=" >> $GITHUB_OUTPUT
          echo "Using provided digest: $D"

      - name: Resolve target digest and version (rollback_previous_stable)
        id: rollback
        if: ${{ github.event.inputs.mode == 'rollback_previous_stable' }}
        run: |
          set -e
          # Determine current stable version label
          CUR="${{ steps.current_stable.outputs.version }}"
          if ! echo "$CUR" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "::warning::Current stable version label missing. Falling back to tag list."
            CUR=""
          fi

          git fetch --tags --force
          # List all semver tags
          mapfile -t TAGS < <(git tag -l "v[0-9]*.[0-9]*.[0-9]*" | sed 's/^v//' | sort -V)

          # If we know current stable version, pick the largest tag < CUR. Else pick the second-largest tag (best-effort).
          TARGET=""
          if [ -n "$CUR" ]; then
            for t in "${TAGS[@]}"; do
              if [ "$t" = "$CUR" ]; then break; fi
              TARGET="$t"
            done
          else
            count=${#TAGS[@]}
            if [ "$count" -ge 2 ]; then
              TARGET="${TAGS[$((count-2))]}"
            fi
          fi

          if [ -z "$TARGET" ]; then
            echo "::error::Could not determine a previous stable tag to roll back to."
            exit 1
          fi

          out=$(docker buildx imagetools inspect "${{ env.IMAGE }}:${TARGET}" 2>/dev/null || true)
          digest=$(echo "$out" | sed -n 's/^Name:\s\+\(.*@sha256:[0-9a-f]\+\).*$/\1/p' | head -n1 | awk -F@ '{print $2}')
          if [ -z "$digest" ]; then
            echo "::error::No manifest found for :$TARGET. Ensure it was published."
            exit 1
          fi

          echo "digest=$digest" >> $GITHUB_OUTPUT
          echo "version=$TARGET" >> $GITHUB_OUTPUT
          echo "Rollback target :$TARGET digest: $digest"

      - name: Summarize plan
        id: plan
        run: |
          mode="${{ github.event.inputs.mode }}"
          dry="${{ github.event.inputs.dry_run }}"
          cur_ver="${{ steps.current_stable.outputs.version }}"
          cur_dig="${{ steps.current_stable.outputs.digest }}"
          tgt_ver=""
          tgt_dig=""
          if [ "$mode" = "by_version" ]; then
            tgt_ver="${{ steps.byver.outputs.version }}"
            tgt_dig="${{ steps.byver.outputs.digest }}"
          elif [ "$mode" = "by_digest" ]; then
            tgt_dig="${{ steps.bydig.outputs.digest }}"
          else
            tgt_ver="${{ steps.rollback.outputs.version }}"
            tgt_dig="${{ steps.rollback.outputs.digest }}"
          fi

          echo "mode=$mode" >> $GITHUB_OUTPUT
          echo "tgt_ver=$tgt_ver" >> $GITHUB_OUTPUT
          echo "tgt_dig=$tgt_dig" >> $GITHUB_OUTPUT

          {
            echo "### Emergency Promotion Plan"
            echo ""
            echo "- Current stable version label: ${cur_ver:-<unknown>}"
            echo "- Current stable digest: ${cur_dig:-<unknown>}"
            echo "- Mode: $mode"
            echo "- Target version: ${tgt_ver:-<none>}"
            echo "- Target digest: ${tgt_dig}"
            echo "- Dry run: ${dry}"
          } >> $GITHUB_STEP_SUMMARY

      - name: Retag :stable to target digest
        if: ${{ github.event.inputs.dry_run == 'false' }}
        run: |
          mode="${{ steps.plan.outputs.mode }}"
          digest=""
          if [ "$mode" = "by_version" ]; then
            digest="${{ steps.byver.outputs.digest }}"
          elif [ "$mode" = "by_digest" ]; then
            digest="${{ steps.bydig.outputs.digest }}"
          else
            digest="${{ steps.rollback.outputs.digest }}"
          fi

          if [ -z "$digest" ]; then
            echo "::error::No target digest resolved."
            exit 1
          fi

          docker buildx imagetools create \
            -t "${{ env.IMAGE }}:stable" \
            "${{ env.IMAGE }}@${digest}"

          echo "Retagged :stable to digest $digest"

      - name: Flip GitHub Release to non-prerelease (if version known)
        if: ${{ github.event.inputs.update_release == 'true' && (github.event.inputs.mode == 'by_version' || github.event.inputs.mode == 'rollback_previous_stable') && github.event.inputs.dry_run == 'false' }}
        uses: actions/github-script@v7
        with:
          script: |
            const mode = '${{ github.event.inputs.mode }}';
            const tgtVer = mode === 'by_version'
              ? '${{ steps.byver.outputs.version }}'
              : '${{ steps.rollback.outputs.version }}';

            if (!tgtVer || !/^\d+\.\d+\.\d+$/.test(tgtVer)) {
              core.info('No target version available for release flip.');
              return;
            }
            const tag = `v${tgtVer}`;

            try {
              const { data: rels } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              const rel = rels.find(r => r.tag_name === tag);
              if (!rel) {
                core.info(`No release found for ${tag}. Skipping flip.`);
              } else if (rel.prerelease) {
                await github.rest.repos.updateRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: rel.id,
                  prerelease: false
                });
                core.info(`Release ${tag} flipped to non-prerelease.`);
              } else {
                core.info(`Release ${tag} already non-prerelease.`);
              }
            } catch (e) {
              core.warning(`Failed to update release: ${e.message}`);
            }

      - name: Final summary
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Operation completed." >> $GITHUB_STEP_SUMMARY
