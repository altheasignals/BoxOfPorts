name: bump-version

on:
  workflow_dispatch:
    inputs:
      track:
        description: "Which track to bump: dev or stable"
        required: true
        default: "dev"
        type: choice
        options: [dev, stable]
      bump:
        description: "Bump type when computing next version"
        required: false
        default: "patch"
        type: choice
        options: [patch, minor, major]
      base:
        description: "Override base version (X.Y.Z). If set, skips detection."
        required: false
      next_version:
        description: "Explicit next version (X.Y.Z). If set, skips bump calculation."
        required: false
      promote_stable_now:
        description: "When track=stable: after tagging, retag :stable to this version"
        required: false
        default: "false"
        type: choice
        options: ["false", "true"]
      flip_release:
        description: "When promoting: flip GitHub Release to non-prerelease"
        required: false
        default: "true"
        type: choice
        options: ["false", "true"]

permissions:
  contents: write

concurrency:
  group: bump-version
  cancel-in-progress: false

env:
  IMAGE: docker.io/altheasignals/boxofports

jobs:
  bump:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # need tags

      - name: Validate inputs
        run: |
          T="${{ github.event.inputs.track }}"
          case "$T" in
            dev|stable) ;;
            *) echo "::error::Invalid track '$T' (use dev|stable)"; exit 1 ;;
          esac
          B="${{ github.event.inputs.bump }}"
          case "$B" in
            patch|minor|major) ;;
            "") ;;
            *) echo "::error::Invalid bump '$B'"; exit 1 ;;
          esac
          NV="${{ github.event.inputs.next_version }}"
          if [ -n "$NV" ] && ! echo "$NV" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "::error::Invalid next_version '$NV' (expected X.Y.Z)"; exit 1
          fi
          BV="${{ github.event.inputs.base }}"
          if [ -n "$BV" ] && ! echo "$BV" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "::error::Invalid base '$BV' (expected X.Y.Z)"; exit 1
          fi

      - name: Install tools (jq + skopeo)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq skopeo

      - name: Detect base from Docker tag (trackâ†’tag)
        id: docker_base
        if: github.event.inputs.base == '' && github.event.inputs.next_version == ''
        env:
          DH_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          DH_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          set -e
          TAG="latest"
          if [ "${{ github.event.inputs.track }}" = "stable" ]; then TAG="stable"; fi

          AUTH=""
          if [ -n "$DH_USER" ] && [ -n "$DH_TOKEN" ]; then
            AUTH="--creds ${DH_USER}:${DH_TOKEN}"
          fi

          VER=""
          if skopeo inspect $AUTH docker://${{ env.IMAGE }}:${TAG} > /tmp/ins.json 2>/dev/null; then
            VER=$(jq -r '.Labels["org.opencontainers.image.version"] // .Labels["io.boxofports.version"] // empty' /tmp/ins.json)
          fi

          echo "version=$VER" >> $GITHUB_OUTPUT
          echo "Detected Docker ${TAG} base: ${VER:-<none>}"

      - name: Fallback base to highest semver git tag
        id: git_base
        if: github.event.inputs.base == '' && github.event.inputs.next_version == '' && steps.docker_base.outputs.version == ''
        run: |
          git fetch --tags --force
          LATEST=$(git tag -l "v[0-9]*.[0-9]*.[0-9]*" | sort -V | tail -n1)
          if [ -n "$LATEST" ]; then
            echo "version=${LATEST#v}" >> $GITHUB_OUTPUT
            echo "Using fallback git base: ${LATEST#v}"
          else
            echo "version=0.0.0" >> $GITHUB_OUTPUT
            echo "No tags found, using base 0.0.0"
          fi

      - name: Choose base
        id: base
        run: |
          if [ -n "${{ github.event.inputs.base }}" ]; then
            BASE="${{ github.event.inputs.base }}"
          elif [ -n "${{ steps.docker_base.outputs.version }}" ]; then
            BASE="${{ steps.docker_base.outputs.version }}"
          elif [ -n "${{ steps.git_base.outputs.version }}" ]; then
            BASE="${{ steps.git_base.outputs.version }}"
          else
            BASE="0.0.0"
          fi
          echo "version=$BASE" >> $GITHUB_OUTPUT
          echo "Base version: $BASE"

      - name: Compute or accept next version
        id: next
        run: |
          set -euo pipefail

          if [ -n "${{ github.event.inputs.next_version }}" ]; then
            NEXT="${{ github.event.inputs.next_version }}"
          else
            BASE="${{ steps.base.outputs.version }}"
            BUMP="${{ github.event.inputs.bump }}"
            # Pass BASE and BUMP as argv to Python to avoid env/exports issues
            NEXT=$(python3 - "$BASE" "$BUMP" << 'PY'
            import sys, re
            base = (sys.argv[1] if len(sys.argv) > 1 else "").strip()
            bump = (sys.argv[2] if len(sys.argv) > 2 else "patch").strip().lower()
            m = re.match(r'^(\d+)\.(\d+)\.(\d+)$', base)
            if not m:
                print(f"ERROR: invalid base '{base}'", file=sys.stderr); sys.exit(1)
            maj, minr, pat = map(int, m.groups())
            if bump == "major":
                maj, minr, pat = maj+1, 0, 0
            elif bump == "minor":
                minr, pat = minr+1, 0
            else:
                pat += 1
            print(f"{maj}.{minr}.{pat}")
            PY
            )
          fi
          echo "version=$NEXT" >> "$GITHUB_OUTPUT"
          echo "Next version: $NEXT"

      - name: Create annotated tag
        run: |
          V="${{ steps.next.outputs.version }}"
          if ! echo "$V" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "::error::Bad next version '$V'"
            exit 1
          fi

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          TAG="v${V}"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists. Nothing to do."
          else
            git tag -a "$TAG" -m "manual bump: ${TAG} (track=${{ github.event.inputs.track }})"
            git push origin "$TAG"
            echo "Created and pushed $TAG"
          fi

      - name: Summary
        run: |
          echo "Track: ${{ github.event.inputs.track }}" >> $GITHUB_STEP_SUMMARY
          echo "Base:  ${{ steps.base.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "Next:  ${{ steps.next.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "Tag:   v${{ steps.next.outputs.version }}" >> $GITHUB_STEP_SUMMARY

  promote_if_requested:
    needs: bump
    if: github.event.inputs.track == 'stable' && github.event.inputs.promote_stable_now == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker login
        uses: docker/login-action@v3
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Wait for image manifest and resolve digest
        id: digest
        run: |
          V="${{ needs.bump.outputs.next_version || '' }}"
          # When job outputs aren't used, recompute from tag name we just pushed:
          if [ -z "$V" ]; then
            V="${{ github.event.workflow_run.head_branch }}"
          fi
          V="${{ needs.bump.outputs.next_version }}"
          if [ -z "$V" ]; then
            echo "::notice::Deriving version from tagging step."
            V="${{ github.event.inputs.next_version }}"
            [ -z "$V" ] && V="${{ github.event.inputs.base }}"
            [ -z "$V" ] && { echo "::error::Cannot derive version."; exit 1; }
          fi

          # Poll for manifest availability
          tries=30
          sleep_s=10
          digest=""
          for i in $(seq 1 $tries); do
            out=$(docker buildx imagetools inspect "${{ env.IMAGE }}:${V}" 2>/dev/null || true)
            digest=$(echo "$out" | sed -n 's/^Name:\s\+\(.*@sha256:[0-9a-f]\+\).*$/\1/p' | head -n1 | awk -F@ '{print $2}')
            if [ -n "$digest" ]; then
              echo "digest=$digest" >> $GITHUB_OUTPUT
              echo "Resolved digest: $digest"
              break
            fi
            echo "Waiting for ${V} manifest... ($i/$tries)"
            sleep $sleep_s
          done

          if [ -z "$digest" ]; then
            echo "::error::Could not resolve digest for :$V. Make sure publish-on-tag finished."
            exit 1
          fi

      - name: Point :stable to this digest
        run: |
          docker buildx imagetools create \
            -t "${{ env.IMAGE }}:stable" \
            "${{ env.IMAGE }}@${{ steps.digest.outputs.digest }}"

      - name: Flip GitHub Release to non-prerelease (optional)
        if: github.event.inputs.flip_release == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const version = `${{ needs.bump.outputs.next_version || github.event.inputs.next_version || github.event.inputs.base }}`;
            const tag = `v${version}`;
            const { data: rels } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const rel = rels.find(r => r.tag_name === tag);
            if (!rel) {
              core.info(`No release found for ${tag}. Skipping flip.`);
            } else if (rel.prerelease) {
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: rel.id,
                prerelease: false
              });
              core.info(`Release ${tag} flipped to non-prerelease.`);
            } else {
              core.info(`Release ${tag} already non-prerelease.`);
            }

      - name: Promotion summary
        run: |
          echo "Promoted ${{ needs.bump.outputs.next_version || github.event.inputs.next_version || github.event.inputs.base }} to :stable" >> $GITHUB_STEP_SUMMARY
