#!/usr/bin/env bash
# bop (Docker wrapper) v1.2.0

# bop - Docker wrapper for BoxOfPorts CLI
# "When the music never stops... the container keeps running"
#
# This wrapper ensures you're always running the latest stable version
# of BoxOfPorts via Docker, with automatic version checking and updates.

set -euo pipefail

# Configuration
readonly DOCKER_IMAGE="altheasignals/boxofports"
readonly DOCKER_TAG_STABLE="stable"
readonly DOCKER_TAG_LATEST="latest"
readonly HOME_CONFIG_DIR="${HOME}/.boxofports"
readonly VERSION_CACHE_FILE="${HOME_CONFIG_DIR}/.bop_version_cache"
readonly FORCE_UPDATE_FILE="${HOME_CONFIG_DIR}/.bop_force_update"
readonly CONFIG_FILE="${HOME_CONFIG_DIR}/bop.conf"
readonly UPDATE_CHECK_FILE="${HOME_CONFIG_DIR}/.bop_update_check"
readonly REMOTE_BOP_URL="https://raw.githubusercontent.com/altheasignals/BoxOfPorts/main/scripts/bop"
readonly BOP_SCRIPT_PATH="$(readlink -f "$0" 2>/dev/null || echo "$0")"

# Colors for output (keeping it groovy)
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m' 
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color

# Logging functions with a touch of cosmic vibes
log_info() {
    echo -e "${BLUE}ðŸŽµ $*${NC}" >&2
}

log_success() {
    echo -e "${GREEN}âœ“ $*${NC}" >&2  
}

log_warning() {
    echo -e "${YELLOW}âš ï¸  $*${NC}" >&2
}

log_error() {
    echo -e "${RED}âœ— $*${NC}" >&2
}

log_cosmic() {
    echo -e "${PURPLE}ðŸŒŒ $*${NC}" >&2
}

# Ensure config directory exists
create_config_dir() {
    if [[ ! -d "$HOME_CONFIG_DIR" ]]; then
        mkdir -p "$HOME_CONFIG_DIR"
        log_info "Created config directory at $HOME_CONFIG_DIR"
    fi
}

# Get current local Docker image version
get_local_version() {
    local tag="$1"
    docker inspect "${DOCKER_IMAGE}:${tag}" --format='{{index .Config.Labels "version"}}' 2>/dev/null || echo "unknown"
}

# Get remote Docker image version from registry  
get_remote_version() {
    local tag="$1"
    # Use docker manifest to get version info without pulling
    docker manifest inspect "${DOCKER_IMAGE}:${tag}" --format='{{index .Config.Labels "version"}}' 2>/dev/null || echo "unknown"
}

# Classify version as stable or dev (deprecated - no longer enforced)
classify_version() {
    local version="$1"
    # All versions are considered valid now - classification is based on track selection
    echo "stable"
}

# Compare versions (returns 0 if v1 >= v2, 1 otherwise)
version_gte() {
    local v1="$1"
    local v2="$2"
    
    # Handle "unknown" versions
    [[ "$v1" == "unknown" ]] && return 1
    [[ "$v2" == "unknown" ]] && return 0
    
    # Use sort -V for semantic version comparison
    [[ "$(printf '%s\n' "$v1" "$v2" | sort -V | tail -n1)" == "$v1" ]]
}

# Update version cache
update_version_cache() {
    local current_version="$1"
    echo "$current_version" > "$VERSION_CACHE_FILE"
    echo "$(date '+%s')" >> "$VERSION_CACHE_FILE"
}

# Get remote bop wrapper version
get_remote_bop_version() {
    local remote_version
    remote_version=$(curl -fsSL "$REMOTE_BOP_URL" 2>/dev/null | grep '^# bop (Docker wrapper) v' | head -n1 | sed 's/.*v\([0-9.]*\).*/\1/' | tr -d '"')
    echo "${remote_version:-unknown}"
}

# Check if bop wrapper update check is stale (older than 24 hours)
is_bop_update_check_stale() {
    [[ ! -f "$UPDATE_CHECK_FILE" ]] && return 0
    
    local check_time
    check_time=$(cat "$UPDATE_CHECK_FILE" 2>/dev/null || echo "0")
    local current_time
    current_time=$(date '+%s')
    local age=$((current_time - check_time))
    
    # Check is stale if older than 24 hours (86400 seconds)
    [[ $age -gt 86400 ]]
}

# Update the bop wrapper script
update_bop_wrapper() {
    local backup_file="${BOP_SCRIPT_PATH}.backup.$(date +%Y%m%d_%H%M%S)"
    
    log_info "Updating bop wrapper..."
    
    # Create backup
    if cp "$BOP_SCRIPT_PATH" "$backup_file" 2>/dev/null; then
        log_info "Created backup: $(basename "$backup_file")"
    else
        log_warning "Could not create backup - continuing anyway"
    fi
    
    # Download new version
    if curl -fsSL "$REMOTE_BOP_URL" -o "${BOP_SCRIPT_PATH}.new" 2>/dev/null; then
        # Verify the download
        if [[ -s "${BOP_SCRIPT_PATH}.new" ]] && head -n1 "${BOP_SCRIPT_PATH}.new" | grep -q "#!/usr/bin/env bash"; then
            # Replace current script
            if mv "${BOP_SCRIPT_PATH}.new" "$BOP_SCRIPT_PATH" 2>/dev/null; then
                chmod +x "$BOP_SCRIPT_PATH" 2>/dev/null || true
                log_success "Bop wrapper updated successfully"
                
                # Clean up old backup files (keep last 3)
                if command -v find >/dev/null 2>&1; then
                    find "$(dirname "$BOP_SCRIPT_PATH")" -name "$(basename "$BOP_SCRIPT_PATH").backup.*" -type f 2>/dev/null | \
                        sort -r | tail -n +4 | xargs rm -f 2>/dev/null || true
                fi
                
                return 0
            else
                log_error "Failed to replace bop script"
            fi
        else
            log_error "Downloaded file appears corrupted"
        fi
        
        # Cleanup failed download
        rm -f "${BOP_SCRIPT_PATH}.new" 2>/dev/null || true
    else
        log_error "Failed to download updated bop wrapper"
    fi
    
    # Restore backup on failure
    if [[ -f "$backup_file" ]]; then
        if mv "$backup_file" "$BOP_SCRIPT_PATH" 2>/dev/null; then
            log_info "Restored from backup after failed update"
        fi
    fi
    
    return 1
}

# Get current bop wrapper version from script header
get_current_bop_version() {
    grep '^# bop (Docker wrapper) v' "$BOP_SCRIPT_PATH" | head -n1 | sed 's/.*v\([0-9.]*\).*/\1/' | tr -d '"'
}

# Check for bop wrapper updates
check_bop_wrapper_updates() {
    # Skip if update check is not stale
    if ! is_bop_update_check_stale; then
        return 0
    fi
    
    # Get versions
    local current_version
    current_version=$(get_current_bop_version)
    local remote_version
    remote_version=$(get_remote_bop_version)
    
    # Update check timestamp
    echo "$(date '+%s')" > "$UPDATE_CHECK_FILE"
    
    if [[ "$remote_version" == "unknown" ]]; then
        # Can't check for updates, but don't fail
        return 0
    fi
    
    # Compare versions
    if ! version_gte "$current_version" "$remote_version"; then
        log_warning "Bop wrapper update available: $current_version â†’ $remote_version"
        
        # Auto-update if we can write to the script location
        if [[ -w "$BOP_SCRIPT_PATH" ]] || [[ -w "$(dirname "$BOP_SCRIPT_PATH")" ]]; then
            log_info "Attempting automatic update..."
            if update_bop_wrapper; then
                log_cosmic "ðŸŽ‰ Bop wrapper updated! Restarting with new version..."
                # Restart with new version
                exec "$BOP_SCRIPT_PATH" "$@"
            fi
        else
            log_warning "Cannot auto-update (no write permission)"
            log_info "ðŸ’¡ To update manually: curl -fsSL $REMOTE_BOP_URL | sudo tee $BOP_SCRIPT_PATH > /dev/null && sudo chmod +x $BOP_SCRIPT_PATH"
        fi
    fi
}

# Check if cache is stale (older than 1 hour)
is_cache_stale() {
    [[ ! -f "$VERSION_CACHE_FILE" ]] && return 0
    
    local cache_time
    cache_time=$(sed -n '2p' "$VERSION_CACHE_FILE" 2>/dev/null || echo "0")
    local current_time
    current_time=$(date '+%s')
    local age=$((current_time - cache_time))
    
    # Cache is stale if older than 1 hour (3600 seconds)
    [[ $age -gt 3600 ]]
}

# Get release track preference (stable, dev, or auto)
get_release_track() {
    # Check for command-line argument first (handled elsewhere)
    # Check environment variable
    if [[ -n "${BOP_RELEASE_TRACK:-}" ]]; then
        echo "${BOP_RELEASE_TRACK}"
        return
    fi
    
    # Check config file
    if [[ -f "$CONFIG_FILE" ]] && grep -q "^release_track=" "$CONFIG_FILE"; then
        grep "^release_track=" "$CONFIG_FILE" | cut -d= -f2 | tr -d '"'
        return
    fi
    
    # Check legacy steal-your-face mode
    if [[ -f "$HOME_CONFIG_DIR/.steal_your_face" ]] || [[ "${BOP_STEAL_YOUR_FACE:-}" == "true" ]]; then
        echo "dev"
        return
    fi
    
    # Default to stable
    echo "stable"
}

# Detect if user wants "Steal Your Face" mode (bleeding edge) - kept for backwards compatibility
is_steal_your_face_mode() {
    [[ "$(get_release_track)" == "dev" ]]
}

# Pull Docker image if needed
pull_image() {
    local tag="$1"
    local force="${2:-false}"
    
    log_info "Checking for image updates..."
    
    # Check if we have the image locally
    if ! docker image inspect "${DOCKER_IMAGE}:${tag}" >/dev/null 2>&1 || [[ "$force" == "true" ]]; then
        log_info "Pulling ${DOCKER_IMAGE}:${tag}..."
        if docker pull "${DOCKER_IMAGE}:${tag}"; then
            log_success "Image updated successfully"
            return 0
        else
            log_error "Failed to pull image"
            return 1
        fi
    fi
    
    # Check versions if not forcing
    if [[ "$force" != "true" ]] && ! is_cache_stale; then
        return 0  # Skip version check if cache is fresh
    fi
    
    local local_version remote_version
    local_version=$(get_local_version "$tag")
    
    log_info "Current version: $local_version"
    
    # Try to get remote version (may fail if registry is unavailable)
    if remote_version=$(get_remote_version "$tag" 2>/dev/null); then
        log_info "Latest version: $remote_version"
        
        if ! version_gte "$local_version" "$remote_version"; then
            log_warning "New version available: $remote_version"
            log_info "Updating to latest version..."
            
            if docker pull "${DOCKER_IMAGE}:${tag}"; then
                log_success "Updated to version $remote_version"
                update_version_cache "$remote_version"
            else
                log_error "Failed to update image"
                return 1
            fi
        else
            log_success "You're on the latest version"
            update_version_cache "$local_version"
        fi
    else
        log_warning "Could not check for updates (registry unavailable)"
        update_version_cache "$local_version"
    fi
}

# Force stable version update if needed
check_stable_enforcement() {
    local current_tag="$1"
    local current_version="$2"
    
    # Only enforce if running stable tag
    [[ "$current_tag" != "$DOCKER_TAG_STABLE" ]] && return 0
    
    # Check if current version is actually stable
    if ! is_stable_version "$current_version"; then
        log_warning "Current version $current_version is not stable"
        log_info "Checking for latest stable release..."
        
        # Force pull stable
        if pull_image "$DOCKER_TAG_STABLE" "true"; then
            local new_version
            new_version=$(get_local_version "$DOCKER_TAG_STABLE")
            if is_stable_version "$new_version"; then
                log_success "Updated to stable version $new_version"
                touch "$FORCE_UPDATE_FILE"
            fi
        fi
    fi
}

# Resolve Docker tag based on release track
resolve_docker_tag() {
    local track="$1"
    
    case "$track" in
        stable)
            echo "$DOCKER_TAG_STABLE"
            ;;
        dev)
            echo "$DOCKER_TAG_LATEST"
            ;;
        auto)
            # Prefer stable, fall back to latest if stable pull fails
            if pull_image "$DOCKER_TAG_STABLE" >/dev/null 2>&1; then
                echo "$DOCKER_TAG_STABLE"
            else
                log_warning "Stable track unavailable, falling back to development track"
                echo "$DOCKER_TAG_LATEST"
            fi
            ;;
        *)
            log_error "Unknown release track: $track. Valid options: stable, dev, auto"
            exit 1
            ;;
    esac
}

# Validate track/version compatibility (deprecated - no longer enforces .0 constraint)
validate_track_version() {
    local track="$1"
    local tag="$2"
    local version="$3"
    
    # Version constraints are deprecated - all versions are valid for any track
    # This function remains for compatibility but no longer enforces restrictions
    return 0
}

# Main image management logic
manage_image() {
    local track
    track=$(get_release_track)
    
    local tag
    tag=$(resolve_docker_tag "$track")
    
    # Show track info
    case "$track" in
        stable)
            log_info "Riding the steady line â€” using stable releases"
            ;;
        dev)
            log_cosmic "Steal Your Face mode active â€” running latest bleeding edge"
            ;;
        auto)
            log_info "Auto mode â€” preferring stable, allowing fallback"
            ;;
    esac
    
    # Pull/update image
    pull_image "$tag"
    
    # Get current version after potential update
    local current_version
    current_version=$(get_local_version "$tag")
    
    # Validate track/version compatibility
    validate_track_version "$track" "$tag" "$current_version"
    
    echo "$tag"
}

# Run boxofports in container
run_boxofports() {
    local docker_tag="$1"
    shift
    
    # Mount home config directory to container
    local docker_args=(
        --rm
        --interactive
        --tty
        --volume "$HOME_CONFIG_DIR:/root/.boxofports"
    )
    
    # Mount current directory if it looks like a project directory
    if [[ -f "pyproject.toml" ]] || [[ -f "setup.py" ]] || [[ -d ".git" ]]; then
        docker_args+=(--volume "$(pwd):/workspace" --workdir /workspace)
    fi
    
    # Pass through relevant environment variables
    local env_vars=(
        "EJOIN_HOST"
        "EJOIN_PORT" 
        "EJOIN_USER"
        "EJOIN_PASSWORD"
        "BOP_PROFILE"
        "BOP_VERBOSE"
    )
    
    for env_var in "${env_vars[@]}"; do
        if [[ -n "${!env_var:-}" ]]; then
            docker_args+=(--env "$env_var=${!env_var}")
        fi
    done
    
    # Execute boxofports with all passed arguments (entrypoint handles the boxofports command)
    log_info "Running boxofports..."
    exec docker run "${docker_args[@]}" "${DOCKER_IMAGE}:${docker_tag}" "$@"
}

# Handle special bop commands
handle_special_commands() {
    case "${1:-}" in
        --track)
            if [[ -z "${2:-}" ]]; then
                log_error "--track requires an argument: stable, dev, or auto"
                exit 1
            fi
            # Validate track argument
            case "$2" in
                stable|dev|auto)
                    export BOP_RELEASE_TRACK="$2"
                    shift 2 # Remove --track and its argument from $@
                    ;;
                *)
                    log_error "Invalid track: $2. Valid options: stable, dev, auto"
                    exit 1
                    ;;
            esac
            ;;
        --steal-your-face)
            if [[ ! -f "$HOME_CONFIG_DIR/.steal_your_face" ]]; then
                touch "$HOME_CONFIG_DIR/.steal_your_face"
                log_cosmic "Steal Your Face mode enabled - you'll get bleeding edge updates"
                log_warning "You're now on the bus! Latest development builds will sync automatically."
            else
                rm -f "$HOME_CONFIG_DIR/.steal_your_face"
                log_info "Steal Your Face mode disabled - returning to stable releases"
            fi
            exit 0
            ;;
        --bop-version)
            local track
            track=$(get_release_track)
            local tag
            tag=$(resolve_docker_tag "$track")
            local version
            version=$(get_local_version "$tag")
            local bop_version
            bop_version=$(get_current_bop_version)
            
            echo "bop (Docker wrapper) v${bop_version}"
            echo "BoxOfPorts container version: $version"
            echo "Docker image: ${DOCKER_IMAGE}:${tag}"
            echo "Release track: $track"
            exit 0
            ;;
        --bop-update)
            log_info "Forcing update check..."
            local track
            track=$(get_release_track)
            local tag
            tag=$(resolve_docker_tag "$track")
            pull_image "$tag" "true"
            log_success "Update complete"
            exit 0
            ;;
        --bop-config)
            echo "Configuration file: $CONFIG_FILE"
            if [[ -f "$CONFIG_FILE" ]]; then
                echo "Current settings:"
                cat "$CONFIG_FILE"
            else
                echo "No configuration file exists. Creating example..."
                cat > "$CONFIG_FILE" << 'EOF'
# BoxOfPorts wrapper configuration
# Set release track: stable (X.Y.0 versions), dev (latest builds), auto (prefer stable)
release_track=stable

# Other settings can go here in the future
EOF
                echo "Created example configuration at $CONFIG_FILE"
            fi
            exit 0
            ;;
        --bop-update-wrapper)
            log_info "Checking for bop wrapper updates..."
            local current_version
            current_version=$(get_current_bop_version)
            local remote_version
            remote_version=$(get_remote_bop_version)
            
            if [[ "$remote_version" == "unknown" ]]; then
                log_warning "Unable to check for updates - network issue or GitHub unavailable"
                exit 1
            fi
            
            if ! version_gte "$current_version" "$remote_version"; then
                log_info "Update available: $current_version â†’ $remote_version"
                if update_bop_wrapper; then
                    log_cosmic "ðŸŽ‰ Bop wrapper updated successfully! Restarting with new version..."
                    exec "$BOP_SCRIPT_PATH" "$@"
                else
                    log_error "Update failed - see messages above"
                    exit 1
                fi
            else
                log_success "Already running latest bop wrapper version ($current_version)"
            fi
            exit 0
            ;;
    esac
}

# Main execution
main() {
    create_config_dir
    
    # Check for bop wrapper updates (skip for --help and internal commands)
    if [[ "${1:-}" != "--help" && "${1:-}" != "-h" && "${1:-}" != "config" && "${1:-}" != "--version" && \
          "${1:-}" != "--bop-version" && "${1:-}" != "--bop-update-wrapper" && "${1:-}" != "--bop-config" ]]; then
        check_bop_wrapper_updates "$@"
    fi
    
    # Handle special bop-specific commands (may modify $@ and environment)
    handle_special_commands "$@"
    
    # Manage Docker image and get appropriate tag
    local docker_tag
    docker_tag=$(manage_image)
    
    # Run boxofports with all arguments
    run_boxofports "$docker_tag" "$@"
}

# Ensure we have Docker
if ! command -v docker >/dev/null 2>&1; then
    log_error "Docker is required but not installed"
    log_info "Please install Docker: https://docs.docker.com/get-docker/"
    exit 1
fi

# Run main function with all arguments
main "$@"