#!/usr/bin/env bash
# bop (Docker wrapper) v1.2.11
#
# Clean, always-fresh wrapper for BoxOfPorts.
# Tracks either :stable or :latest every run with no stale gating.

set -euo pipefail

# --- Config -------------------------------------------------------------------
readonly DOCKER_IMAGE="altheasignals/boxofports"
readonly DOCKER_TAG_STABLE="stable"
readonly DOCKER_TAG_LATEST="latest"

readonly HOME_CONFIG_DIR="${HOME}/.boxofports"
readonly CONFIG_FILE="${HOME_CONFIG_DIR}/bop.conf"

# Kept only for user-facing info; no gating logic uses these files anymore.
readonly VERSION_CACHE_FILE="${HOME_CONFIG_DIR}/.bop_version_cache"

readonly REMOTE_BOP_URL="https://raw.githubusercontent.com/altheasignals/BoxOfPorts/main/scripts/bop"
readonly BOP_SCRIPT_PATH="$(readlink -f "$0" 2>/dev/null || echo "$0")"

# --- UI -----------------------------------------------------------------------
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly NC='\033[0m'

log_info()    { echo -e "${BLUE}$*${NC}"  >&2; }
log_ok()      { echo -e "${GREEN}$*${NC}" >&2; }
log_warn()    { echo -e "${YELLOW}$*${NC}" >&2; }
log_err()     { echo -e "${RED}$*${NC}"   >&2; }
log_cosmic()  { echo -e "${PURPLE}$*${NC}" >&2; }

# --- Helpers ------------------------------------------------------------------
create_config_dir() {
  [[ -d "$HOME_CONFIG_DIR" ]] || { mkdir -p "$HOME_CONFIG_DIR"; log_info "Created $HOME_CONFIG_DIR"; }
}

# Read version label from a local image; prefer OCI key, fallback to project key.
get_local_version() {
  local tag="$1" v=""
  v="$(docker inspect "${DOCKER_IMAGE}:${tag}" --format='{{ index .Config.Labels "org.opencontainers.image.version"}}' 2>/dev/null || true)"
  if [[ -z "${v}" || "${v}" == "<no value>" ]]; then
    v="$(docker inspect "${DOCKER_IMAGE}:${tag}" --format='{{ index .Config.Labels "io.boxofports.version"}}' 2>/dev/null || true)"
  fi
  [[ -n "${v}" && "${v}" != "<no value>" ]] && echo "${v}" || echo "unknown"
}

# Semantic >= using sort -V; unknown is treated as lower.
version_gte() {
  local v1="${1:-unknown}" v2="${2:-unknown}"
  [[ "$v1" == "unknown" ]] && return 1
  [[ "$v2" == "unknown" ]] && return 0
  [[ "$(printf '%s\n' "$v1" "$v2" | sort -V | tail -n1)" == "$v1" ]]
}

# Release track: env > config > default(stable). Steal-Your-Face forces dev.
is_steal_your_face_mode() { [[ -f "$HOME_CONFIG_DIR/.steal_your_face" ]] || [[ "${BOP_STEAL_YOUR_FACE:-}" == "true" ]]; }

get_release_track() {
  if is_steal_your_face_mode; then echo "dev"; return; fi
  if [[ -n "${BOP_RELEASE_TRACK:-}" ]]; then echo "${BOP_RELEASE_TRACK}"; return; fi
  if [[ -f "$CONFIG_FILE" ]] && grep -q '^release_track=' "$CONFIG_FILE"; then
    grep '^release_track=' "$CONFIG_FILE" | cut -d= -f2 | tr -d '"'
    return
  fi
  echo "stable"
}

resolve_docker_tag() {
  case "$1" in
    stable) echo "$DOCKER_TAG_STABLE" ;;
    dev)    echo "$DOCKER_TAG_LATEST" ;;
    *)      log_err "Unknown release track: $1 (expected: stable|dev)"; exit 1 ;;
  esac
}

# Always reconcile with the registry. No TTL, no “stale” checks.
pull_fresh_image() {
  local tag="$1"
  local before after
  before="$(get_local_version "$tag")"

  log_info "Pulling ${DOCKER_IMAGE}:${tag} (always checking registry)…"
  if docker pull "${DOCKER_IMAGE}:${tag}" >/dev/null; then
    after="$(get_local_version "$tag")"
    if [[ "$before" != "unknown" && "$after" != "unknown" && "$before" != "$after" ]]; then
      log_warn "Updated container: ${before} → ${after}"
    else
      log_ok "Image is up to date${after:+ (v${after})}"
    fi
    # Update simple cache file for humans/tools (not used for gating)
    {
      echo "${after}"
      date '+%s'
    } > "${VERSION_CACHE_FILE}" 2>/dev/null || true
  else
    log_err "Failed to pull ${DOCKER_IMAGE}:${tag}"
    exit 1
  fi
}

# --- Wrapper self-update (no 24h throttle; check on each normal run) ----------
get_current_bop_version() {
  grep '^# bop (Docker wrapper) v' "$BOP_SCRIPT_PATH" | head -n1 | sed 's/.*v\([0-9.]*\).*/\1/' | tr -d '"'
}

get_remote_bop_version() {
  local rv
  rv="$(curl -fsSL "$REMOTE_BOP_URL" 2>/dev/null | grep '^# bop (Docker wrapper) v' | head -n1 | sed 's/.*v\([0-9.]*\).*/\1/' | tr -d '"')"
  echo "${rv:-unknown}"
}

update_bop_wrapper() {
  local backup="${BOP_SCRIPT_PATH}.backup.$(date +%Y%m%d_%H%M%S)"
  log_info "Updating bop wrapper…"
  cp "$BOP_SCRIPT_PATH" "$backup" 2>/dev/null || true
  if curl -fsSL "$REMOTE_BOP_URL" -o "${BOP_SCRIPT_PATH}.new" 2>/dev/null; then
    if [[ -s "${BOP_SCRIPT_PATH}.new" ]] && head -n1 "${BOP_SCRIPT_PATH}.new" | grep -q "#!/usr/bin/env bash"; then
      mv "${BOP_SCRIPT_PATH}.new" "$BOP_SCRIPT_PATH"
      chmod +x "$BOP_SCRIPT_PATH" 2>/dev/null || true
      log_ok "Wrapper updated"
      return 0
    fi
  fi
  log_err "Wrapper update failed; keeping current file"
  rm -f "${BOP_SCRIPT_PATH}.new" 2>/dev/null || true
  mv "$backup" "$BOP_SCRIPT_PATH" 2>/dev/null || true
  return 1
}

check_bop_wrapper_updates() {
  local current remote
  current="$(get_current_bop_version)"
  remote="$(get_remote_bop_version)"
  [[ "$remote" == "unknown" ]] && return 0
  if ! version_gte "$current" "$remote"; then
    log_warn "bop update available: ${current:-unknown} → ${remote}"
    if [[ -w "$BOP_SCRIPT_PATH" ]] || [[ -w "$(dirname "$BOP_SCRIPT_PATH")" ]]; then
      if update_bop_wrapper; then
        log_cosmic "wrapper updated — restarting…"
        exec "$BOP_SCRIPT_PATH" "$@"
      fi
    else
      log_warn "No write permission to auto-update."
      log_info  "Manual: curl -fsSL $REMOTE_BOP_URL | sudo tee $BOP_SCRIPT_PATH > /dev/null && sudo chmod +x $BOP_SCRIPT_PATH"
    fi
  fi
}

# --- CLI glue -----------------------------------------------------------------
show_bop_help() {
  cat <<'EOF'
bop — BoxOfPorts Docker wrapper (always-fresh)
Usage:
  bop [boxofports-args…]        Run BoxOfPorts in the configured track
  bop --bop <subcommand>        Control the wrapper

Subcommands:
  version            Show wrapper and container versions
  update             Force repull of the configured track tag
  update-wrapper     Force wrapper self-update
  config             Show/create wrapper config
  track <stable|dev> Switch release track
  steal-your-face    Toggle cosmic dev mode (dev track + vibes)
EOF
}

handle_bop_subcommands() {
  if [[ "${1:-}" != "--bop" ]]; then return 0; fi
  shift
  case "${1:-}" in
    "" ) show_bop_help; exit 0 ;;
    version )
      local track tag version bopv
      track="$(get_release_track)"
      tag="$(resolve_docker_tag "$track")"
      version="$(get_local_version "$tag")"
      bopv="$(get_current_bop_version)"
      echo "bop wrapper: v${bopv:-unknown}"
      echo "Docker image: ${DOCKER_IMAGE}:${tag}"
      echo "Container version: ${version}"
      echo "Release track: ${track}$(is_steal_your_face_mode && echo ' (Steal Your Face)')"
      exit 0
      ;;
    update )
      local track tag
      track="$(get_release_track)"; tag="$(resolve_docker_tag "$track")"
      pull_fresh_image "$tag"; log_ok "Update complete"; exit 0
      ;;
    update-wrapper )
      check_bop_wrapper_updates "--bop" "version"; exit 0
      ;;
    config )
      echo "Config: $CONFIG_FILE"
      if [[ -f "$CONFIG_FILE" ]]; then
        echo "Current settings:"; cat "$CONFIG_FILE"
      else
        mkdir -p "$HOME_CONFIG_DIR"
        cat > "$CONFIG_FILE" <<'CFG'
# BoxOfPorts wrapper configuration
# stable (default) or dev
release_track=stable
CFG
        echo "Created $CONFIG_FILE"
      fi
      exit 0
      ;;
    track )
      [[ -n "${2:-}" ]] || { log_err "--bop track requires: stable|dev"; exit 1; }
      case "$2" in
        stable|dev)
          mkdir -p "$HOME_CONFIG_DIR"
          if [[ -f "$CONFIG_FILE" ]]; then
            # portable in-place sed (BSD/Darwin & GNU)
            sed -i '' 's/^release_track=.*/release_track='"$2"'/' "$CONFIG_FILE" 2>/dev/null || \
            sed -i     's/^release_track=.*/release_track='"$2"'/' "$CONFIG_FILE"
          else
            echo "release_track=$2" > "$CONFIG_FILE"
          fi
          log_ok "Track set to: $2"
          [[ "$2" == "dev" ]] && log_warn "Development track enabled — bleeding edge ahead."
          exit 0
          ;;
        *) log_err "Invalid track: $2"; exit 1 ;;
      esac
      ;;
    steal-your-face )
      if is_steal_your_face_mode; then
        rm -f "$HOME_CONFIG_DIR/.steal_your_face"
        log_info "Steal Your Face disabled — back to steady line."
      else
        touch "$HOME_CONFIG_DIR/.steal_your_face"
        log_cosmic "Steal Your Face enabled — welcome to the cosmic dance."
      fi
      exit 0
      ;;
    * )
      log_err "Unknown subcommand: $1"; show_bop_help; exit 1 ;;
  esac
}

manage_image_and_run() {
  local track tag
  track="$(get_release_track)"
  tag="$(resolve_docker_tag "$track")"

  if is_steal_your_face_mode; then
    log_cosmic "dev track engaged (Steal Your Face)"
  else
    [[ "$track" == "dev" ]] && log_warn "dev track active" || log_info "stable track active"
  fi

  pull_fresh_image "$tag"

  # Runtime mounts
  create_config_dir
  local args=(
    --rm -it
    --user "$(id -u):$(id -g)"
    --env "HOME=/tmp"
    --volume "$HOME_CONFIG_DIR:/tmp/.boxofports"
    --volume "$(pwd):/workspace" --workdir /workspace
  )

  # Pass through useful env vars
  for e in EJOIN_HOST EJOIN_PORT EJOIN_USER EJOIN_PASSWORD BOP_PROFILE BOP_VERBOSE; do
    [[ -n "${!e:-}" ]] && args+=(--env "$e=${!e}")
  done

  log_info "Running boxofports…"
  exec docker run "${args[@]}" "${DOCKER_IMAGE}:${tag}" "$@"
}

main() {
  create_config_dir
  handle_bop_subcommands "$@"
  # Only check wrapper updates on “normal” runs (not when we’re just showing help)
  if [[ $# -gt 0 ]]; then
    check_bop_wrapper_updates "$@"
  fi
  manage_image_and_run "$@"
}

# Docker must be present
if ! command -v docker >/dev/null 2>&1; then
  log_err "Docker is required but not installed"
  log_info "Install Docker: https://docs.docker.com/get-docker/"
  exit 1
fi

main "$@"
